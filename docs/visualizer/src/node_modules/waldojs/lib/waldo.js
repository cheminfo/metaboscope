'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _justCompare = require('just-compare');

var _justCompare2 = _interopRequireDefault(_justCompare);

var GLOBAL = typeof window == 'object' ? window : global;

var find = {
  byName: function byName(what, where) {
    return this.searchMaybe('propName', 'string', what, where);
  },
  byType: function byType(what, where) {
    return this.searchMaybe('type', 'function', what, where);
  },
  byValue: function byValue(what, where) {
    return this.searchMaybe('value', null, what, where);
  },
  byValueCoerced: function byValueCoerced(what, where) {
    return this.searchMaybe('valueCoerced', null, what, where);
  },
  custom: function custom(fn, where) {
    return this.searchMaybe(fn, null, null, where);
  },
  searchMaybe: function searchMaybe(util, expected, what, where) {
    // integrity check arguments
    if (expected && typeof what != expected) {
      throw new Error(what + ' must be ' + expected);
    }
    // only console.log if we are the global function
    if (this === GLOBAL.waldo) {
      GLOBAL.DEBUG = true;
    }
    return search(util, what, where);
  }
};

function search(util, what) {
  var where = arguments.length <= 2 || arguments[2] === undefined ? GLOBAL : arguments[2];

  util = searchBy[util] || util;

  var data = undefined;
  var alreadySeen = undefined;

  var path = where == GLOBAL ? 'GLOBAL' : 'SRC';
  var queue = [{ where: where, path: path }];
  var seen = [];

  var matches = [];
  matches.log = function () {
    this.forEach(function (m) {
      return m.log();
    });
  };

  // a non-recursive solution to avoid call stack limits
  // http://www.jslab.dk/articles/non.recursive.preorder.traversal.part4
  while (data = queue.pop()) {
    var _data = data;
    var _where = _data.where;
    var _path = _data.path;

    for (var prop in _where) {
      // IE may throw errors when accessing/coercing some properties
      try {
        if (_where.hasOwnProperty(prop)) {
          // inspect objects
          if ([_where[prop]] == '[object Object]') {
            // check if already searched (prevents circular references)
            for (var i = -1; seen[++i] && !(alreadySeen = (0, _justCompare2['default'])(seen[i].where, _where[prop]) && seen[i]););
            // add to stack
            if (!alreadySeen) {
              data = { where: _where[prop], path: _path + '.' + prop };
              queue.push(data);
              seen.push(data);
            }
          }
          // if match detected, push it.
          if (util(what, _where, prop)) {
            var type = alreadySeen ? '<' + alreadySeen.path + '>' : typeof _where[prop];
            var match = new Match({ path: _path + '.' + prop, obj: _where, prop: prop, type: type });
            matches.push(match);
            GLOBAL.DEBUG && match.log();
          }
        }
      } catch (e) {}
    }
  }

  return matches;
}

var searchBy = {
  propName: function propName(what, where, prop) {
    return what == prop;
  },
  type: function type(what, where, prop) {
    return where[prop] instanceof what;
  },
  value: function value(what, where, prop) {
    return where[prop] === what;
  },
  valueCoerced: function valueCoerced(what, where, prop) {
    return where[prop] == what;
  }
};

var Match = (function () {
  function Match(props) {
    _classCallCheck(this, Match);

    _Object$assign(this, props);
    this.value = this.obj[this.prop];
  }

  // for console running

  _createClass(Match, [{
    key: 'toString',
    value: function toString() {
      var path = this.path;
      var type = this.type;

      return path + ' -> (' + type + ') ' + this.logValue();
    }
  }, {
    key: 'logValue',
    value: function logValue() {
      var val = this.value;
      // if value is an object then just toString it
      var isPrimitive = function isPrimitive(x) {
        return Object(x) !== x;
      };
      return isPrimitive(val) || Array.isArray(val) ? val : ({}).toString.call(val);
    }
  }, {
    key: 'log',
    value: function log() {
      console.log(this.toString());
    }
  }]);

  return Match;
})();

GLOBAL.waldo = _Object$assign({}, find, { debug: true });

exports['default'] = find;
module.exports = exports['default'];